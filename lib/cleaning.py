def construct_outlier_mask(order,w,c_thresh):
    print('THIS DOESNT EXIST YET')
    return(order*0.0+1.0)


def clean_ccf(rv,ccf,ccf_e,dp):
    """This routine normalizes the CCF fluxes and subtracts the average out of
    transit CCF, using the transit lightcurve as a mask."""

    import numpy as np
    import lib.functions as fun
    import lib.utils as ut
    from matplotlib import pyplot as plt
    import pdb
    import lib.system_parameters as sp
    ut.typetest('rv in clean_ccf',rv,np.ndarray)
    ut.typetest('ccf in clean_ccf',ccf,np.ndarray)
    ut.typetest('ccf_e in clean_ccf',ccf_e,np.ndarray)
    ut.typetest('dp in clean_ccf',dp,str)
    ut.dimtest(ccf,[0,len(rv)])
    ut.dimtest(ccf_e,[0,len(rv)])
    ut.nantest('rv in clean_ccf',rv)
    ut.nantest('ccf in clean_ccf',ccf)
    ut.nantest('ccf_e in clean_ccf',ccf_e)


    transit=sp.transit(dp)

    meanflux=np.median(ccf,axis=1)#Normalize the baseline flux.
    meanblock=fun.rebinreform(meanflux,len(rv))
    ccf_n = ccf/meanblock.T
    ccf_ne = ccf_e/meanblock.T
    meanccf=np.mean(ccf_n[transit == 1.0,:],axis=0)
    meanblock=fun.rebinreform(meanccf,len(meanflux))
    ccf_nn = ccf_n-meanblock
    return(ccf_n,ccf_ne,ccf_nn)



def construct_doppler_model_vincent(filename,dp,rv,ccf):
    """This takes a two-column dat-file generated by Vincent (with phase versus
    shadow RV) and matches it to (interpolates onto) the phases of the data."""
    from astropy.io import ascii
    import numpy as np
    import lib.system_parameters as sp
    import lib.utils as ut
    import scipy.interpolate
    import scipy.optimize
    import pdb
    import sys
    import matplotlib.pyplot as plt
    import astropy.io.fits as fits
    data = ascii.read(filename,names=['phase','rv'])
    phase=sp.phase(dp)
    vsys = sp.paramget('vsys',dp)
    phase_data=data['phase'].data
    phase[phase > 0.5] -= 1.0
    v_i=scipy.interpolate.interp1d(phase_data,data['rv'].data,bounds_error=False,fill_value='extrapolate')
    v_out = v_i(phase)
    v_out[phase < phase_data.min()] = np.nan
    v_out[phase > phase_data.max()] = np.nan
    transit=-1.0*(sp.transit(dp)-1.0)
    transit/=np.max(transit)


    def shadow(params,rv,ccf,transit,flatten=True):
        import numpy as np
        import lib.functions as fun
        import pdb
        modelled_ccf = ccf*0.0
        nexp = np.shape(ccf)[0]
        cont=np.median(ccf)
        for i in range(nexp):
            modelled_ccf[i,:] = transit[i]*params[0] * np.exp(-(rv-v_out[i]-vsys-params[1])**2 / (2*params[2]**2)) + cont + transit[i]*params[3] * np.exp(-(rv-v_out[i]-vsys-params[1])**2 / (2*params[4]**2))

        diffs = modelled_ccf - ccf
        diffs[np.isnan(diffs)] = 0.0
        if flatten == True:
            return diffs.flatten() # it expects a 1D array out.
        else:
            return diffs
       # it doesn't matter that it's conceptually 2D, provided flatten it consistently

    result = scipy.optimize.leastsq(shadow,[0.005,0.5,4.0,-0.002,15.0],args = (rv,ccf,transit)) # alternatively you can do this with closure variables in f if you like
    print(result[0])
    model = shadow(result[0],rv,ccf*0.0,transit,flatten=False)
    ut.save_stack('test_ds.fits',[ccf,model,ccf-model])

# result is the best fit point

    return(v_out+result[0][1],model)
